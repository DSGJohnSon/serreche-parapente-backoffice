// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum Role {
  ADMIN
  MONITEUR
  CUSTOMER
}

enum StageType {
  INITIATION
  PROGRESSION
  AUTONOMIE
  DOUBLE
}

enum StageBookingType {
  INITIATION
  PROGRESSION
  AUTONOMIE
}

enum BaptemeCategory {
  AVENTURE
  DUREE
  LONGUE_DUREE
  ENFANT
  HIVER
}

// Nouveaux enums pour le système de panier
enum CartItemType {
  STAGE
  BAPTEME
  GIFT_CARD
  GIFT_VOUCHER
}

enum VoucherProductType {
  STAGE
  BAPTEME
}

enum OrderStatus {
  PENDING
  PAID
  PARTIALLY_PAID
  FULLY_PAID
  CONFIRMED
  CANCELLED
  REFUNDED
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  CANCELLED
  REFUNDED
}

enum ManualPaymentMethod {
  CARD
  BANK_TRANSFER
  CASH
  CHECK
}

//Catégories de baptêmes avec leurs prix fixes
model BaptemeCategoryPrice {
  id       String          @id @default(cuid())
  category BaptemeCategory @unique
  price    Float

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Prix de l'option vidéo pour les baptêmes
model VideoOptionPrice {
  id    String @id @default(cuid())
  price Float

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Prix de l'acompte par défaut pour les baptêmes
model BaptemeDepositPrice {
  id    String @id @default(cuid())
  price Float  @default(35.0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Prix de base des stages par type
model StageBasePrice {
  id        String    @id @default(cuid())
  stageType StageType @unique
  price     Float

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//Créneau de stage de parapente (similaire aux baptêmes)
model Stage {
  id               String    @id @default(cuid())
  startDate        DateTime // Plus de contrainte unique pour permettre plusieurs stages par jour
  duration         Int       @default(7) // Durée en jours
  places           Int       @default(6)
  price            Float     @default(350.0) // Prix en euros
  allTimeHighPrice Float // Prix "All Time High"
  acomptePrice     Float     @default(100.0) // Montant de l'acompte
  type             StageType @default(INITIATION)

  // Relation many-to-many avec les moniteurs
  moniteurs StageMoniteur[]
  bookings  StageBooking[]

  // Nouvelles relations pour le système de panier
  cartItems             CartItem[]
  orderItems            OrderItem[]
  temporaryReservations TemporaryReservation[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//Table de liaison pour les moniteurs de stages
model StageMoniteur {
  id         String @id @default(cuid())
  stageId    String
  moniteurId String
  stage      Stage  @relation(fields: [stageId], references: [id], onDelete: Cascade)
  moniteur   User   @relation("StageMoniteurs", fields: [moniteurId], references: [id])

  createdAt DateTime @default(now())

  @@unique([stageId, moniteurId])
}

//Créneau de bapteme
model Bapteme {
  id           String            @id @default(cuid())
  date         DateTime          @unique
  duration     Int               @default(120) // Durée en minutes
  places       Int               @default(6)
  categories   BaptemeCategory[] // Catégories disponibles sur ce créneau
  acomptePrice Float             @default(35.0) // Montant de l'acompte

  // Relation many-to-many avec les moniteurs
  moniteurs BaptemeMoniteur[]
  bookings  BaptemeBooking[]

  // Nouvelles relations pour le système de panier
  cartItems             CartItem[]
  orderItems            OrderItem[]
  temporaryReservations TemporaryReservation[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//Table de liaison pour les moniteurs de baptêmes
model BaptemeMoniteur {
  id         String  @id @default(cuid())
  baptemeId  String
  moniteurId String
  bapteme    Bapteme @relation(fields: [baptemeId], references: [id], onDelete: Cascade)
  moniteur   User    @relation("BaptemeMoniteurs", fields: [moniteurId], references: [id])

  createdAt DateTime @default(now())

  @@unique([baptemeId, moniteurId])
}

//Réservation d'une semaine de stage de parapente (Lien entre Stage et Stagiaire)
model StageBooking {
  id          String           @id @default(cuid())
  type        StageBookingType @default(INITIATION)
  stageId     String
  stage       Stage            @relation(fields: [stageId], references: [id])
  stagiaireId String
  stagiaire   Stagiaire        @relation(fields: [stagiaireId], references: [id])

  // Relation avec OrderItem
  orderItem OrderItem?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//Réservation d'un créneau de bapteme (Lien entre Bapteme et Stagiaire)
model BaptemeBooking {
  id          String          @id @default(cuid())
  baptemeId   String
  bapteme     Bapteme         @relation(fields: [baptemeId], references: [id])
  stagiaireId String
  stagiaire   Stagiaire       @relation(fields: [stagiaireId], references: [id])
  category    BaptemeCategory // Catégorie choisie par le stagiaire
  hasVideo    Boolean         @default(false) // Option vidéo sélectionnée

  // Relation avec OrderItem
  orderItem OrderItem?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model GiftCard {
  id              String   @id @default(cuid())
  code            String   @unique
  amount          Float    @default(0.0) // Montant initial en euros
  remainingAmount Float    @default(0.0) // Montant restant disponible
  isUsed          Boolean  @default(false) // True quand remainingAmount = 0
  expiryDate      DateTime @default(dbgenerated("CURRENT_DATE + INTERVAL '1 year'")) // Expire après 1 an par défaut
  clientId        String?
  client          Client?  @relation(name: "GiftCardBuyer", fields: [clientId], references: [id])

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  usedAt        DateTime? // Date de première utilisation
  usedByOrderId String? // ID de la dernière commande qui a utilisé la carte-cadeau (deprecated, use orderGiftCards)

  // Nouvelles relations pour le système de commandes
  appliedToOrders        OrderGiftCard[] // Many-to-many avec Order
  deprecatedOrders       Order[]         @relation("DeprecatedGiftCard")
  generatedFromOrderItem OrderItem[]     @relation("GeneratedGiftCard")
}

// Bon cadeau (Gift Voucher) - Place gratuite pour un stage ou baptême
model GiftVoucher {
  id   String @id @default(cuid())
  code String @unique // Format: GVSCP-XXXXXXXX-XXXX

  // Type et catégorie
  productType     VoucherProductType
  stageCategory   StageBookingType? // Si productType = STAGE
  baptemeCategory BaptemeCategory? // Si productType = BAPTEME

  // Prix d'achat (snapshot au moment de l'achat)
  purchasePrice Float

  // Statut
  isUsed Boolean   @default(false)
  usedAt DateTime?

  // Bénéficiaire
  recipientName  String
  recipientEmail String

  // Acheteur
  clientId String?
  client   Client? @relation(fields: [clientId], references: [id])

  // Validité
  expiryDate DateTime

  // Réservation temporaire (panier)
  reservedBySessionId String? // Session qui a le bon dans son panier
  reservedAt          DateTime? // Date de réservation

  // Relations avec OrderItems
  generatedFromOrderItem OrderItem? @relation("GeneratedVoucher")
  usedInOrderItem        OrderItem? @relation("UsedVoucher")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([code])
  @@index([isUsed])
  @@index([reservedBySessionId])
  @@index([expiryDate])
}

// Client (celui qui paie la commande)
model Client {
  id         String  @id @default(cuid())
  firstName  String
  lastName   String
  email      String? @unique
  phone      String
  address    String
  postalCode String
  city       String
  country    String

  // Relations
  orders       Order[]
  giftCards    GiftCard[]    @relation(name: "GiftCardBuyer")
  giftVouchers GiftVoucher[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Stagiaire (celui qui participe aux stages/baptêmes)
model Stagiaire {
  id        String    @id @default(cuid())
  firstName String
  lastName  String
  email     String
  phone     String
  birthDate DateTime? // Date de naissance (pour calculer l'âge)
  weight    Float
  height    Float

  // Relations
  stageBookings   StageBooking[]
  baptemeBookings BaptemeBooking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
}

//Admin
model User {
  id        String   @id @unique
  email     String   @unique
  name      String
  avatarUrl String
  role      Role     @default(CUSTOMER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations many-to-many avec les stages et baptêmes
  stageMoniteurs   StageMoniteur[]   @relation("StageMoniteurs")
  baptemeMoniteurs BaptemeMoniteur[] @relation("BaptemeMoniteurs")

  // Paiements enregistrés par cet utilisateur
  recordedPayments Payment[]
}

// Session temporaire pour les paniers non-authentifiés
model CartSession {
  id        String   @id @default(cuid())
  sessionId String   @unique // UUID généré côté client
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  cartItems CartItem[]

  @@index([expiresAt])
  @@index([sessionId])
}

// Articles dans le panier
model CartItem {
  id       String       @id @default(cuid())
  type     CartItemType
  quantity Int          @default(1)

  // Références optionnelles selon le type
  stageId String?
  stage   Stage?  @relation(fields: [stageId], references: [id])

  baptemeId String?
  bapteme   Bapteme? @relation(fields: [baptemeId], references: [id])

  // Pour les cartes cadeaux
  giftCardAmount Float?

  // Pour les bons cadeaux (gift vouchers)
  giftVoucherCode   String? // Code du bon cadeau utilisé
  giftVoucherAmount Float? // Montant du bon cadeau à acheter

  // Informations du participant (temporaires, avant paiement)
  participantData Json // {firstName, lastName, email, phone, weight, height, birthDate?}

  // Session uniquement (pas de lien client avant paiement)
  cartSessionId String
  cartSession   CartSession @relation(fields: [cartSessionId], references: [id], onDelete: Cascade)

  // Système de réservation temporaire (1 heure pour STAGE/BAPTEME)
  expiresAt DateTime? // Date d'expiration (createdAt + 1h pour STAGE/BAPTEME, null pour GIFT_CARD)
  isExpired Boolean   @default(false) // Flag calculé pour identifier les items expirés

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([cartSessionId])
  @@index([expiresAt])
  @@index([isExpired])
}

// Réservation temporaire pour gérer les stocks
model TemporaryReservation {
  id        String @id @default(cuid())
  sessionId String // Session du panier

  // Référence à l'activité
  stageId String?
  stage   Stage?  @relation(fields: [stageId], references: [id])

  baptemeId String?
  bapteme   Bapteme? @relation(fields: [baptemeId], references: [id])

  quantity  Int      @default(1)
  expiresAt DateTime // 15 minutes par défaut

  createdAt DateTime @default(now())

  @@index([expiresAt])
  @@index([sessionId])
}

// Commande principale
model Order {
  id          String      @id @default(cuid())
  orderNumber String      @unique // Format: ORD-YYYY-XXXXXX
  status      OrderStatus @default(PENDING)

  // Montants
  subtotal       Float
  discountAmount Float @default(0.0)
  totalAmount    Float

  // Relation avec le client (celui qui paie) - Optionnel jusqu'au paiement
  clientId String?
  client   Client? @relation(fields: [clientId], references: [id])

  // Bon cadeau utilisé (deprecated - use orderGiftCards for many-to-many)
  appliedGiftCardId String?
  appliedGiftCard   GiftCard? @relation("DeprecatedGiftCard", fields: [appliedGiftCardId], references: [id])

  // Relations
  orderItems     OrderItem[]
  payments       Payment[]
  orderGiftCards OrderGiftCard[] // Many-to-many avec GiftCard

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderNumber])
  @@index([clientId])
  @@index([status])
  @@index([createdAt])
}

// Table de liaison pour les cartes cadeaux appliquées aux commandes
model OrderGiftCard {
  id         String   @id @default(cuid())
  orderId    String
  order      Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  giftCardId String
  giftCard   GiftCard @relation(fields: [giftCardId], references: [id])

  // Montant utilisé de cette carte cadeau pour cette commande
  usedAmount Float

  createdAt DateTime @default(now())

  @@unique([orderId, giftCardId])
  @@index([orderId])
  @@index([giftCardId])
}

// Articles de la commande
model OrderItem {
  id      String @id @default(cuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  type       CartItemType
  quantity   Int          @default(1)
  unitPrice  Float
  totalPrice Float

  // Références selon le type
  stageId String?
  stage   Stage?  @relation(fields: [stageId], references: [id])

  baptemeId String?
  bapteme   Bapteme? @relation(fields: [baptemeId], references: [id])

  // Pour les cartes cadeaux
  giftCardAmount      Float?
  generatedGiftCardId String?
  generatedGiftCard   GiftCard? @relation("GeneratedGiftCard", fields: [generatedGiftCardId], references: [id])

  // Pour les bons cadeaux (gift vouchers)
  giftVoucherAmount      Float? // Montant du bon cadeau acheté
  generatedGiftVoucherId String?      @unique
  generatedGiftVoucher   GiftVoucher? @relation("GeneratedVoucher", fields: [generatedGiftVoucherId], references: [id])

  usedGiftVoucherId String?      @unique
  usedGiftVoucher   GiftVoucher? @relation("UsedVoucher", fields: [usedGiftVoucherId], references: [id])

  // Données du participant (historique JSON)
  participantData Json // {firstName, lastName, email, phone, weight, height, birthDate?}

  // Gestion des acomptes (stages uniquement)
  depositAmount    Float? // Montant de l'acompte payé (pour les stages)
  remainingAmount  Float? // Montant restant à payer (pour les stages)
  isFullyPaid      Boolean   @default(false) // True quand tout est payé
  finalPaymentDate DateTime? // Date du paiement final en physique
  finalPaymentNote String? // Note optionnelle sur le paiement final

  // Réservations créées (liées au stagiaire)
  stageBookingId String?       @unique
  stageBooking   StageBooking? @relation(fields: [stageBookingId], references: [id])

  baptemeBookingId String?         @unique
  baptemeBooking   BaptemeBooking? @relation(fields: [baptemeBookingId], references: [id])

  // Relation avec les paiements (many-to-many)
  paymentAllocations PaymentAllocation[]

  createdAt DateTime @default(now())

  @@index([orderId])
}

// Table de liaison pour répartir les paiements entre les OrderItems
model PaymentAllocation {
  id          String    @id @default(cuid())
  paymentId   String
  payment     Payment   @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  orderItemId String
  orderItem   OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)

  // Montant alloué de ce paiement à cet OrderItem
  allocatedAmount Float

  createdAt DateTime @default(now())

  @@unique([paymentId, orderItemId])
  @@index([paymentId])
  @@index([orderItemId])
}

// Paiements
model Payment {
  id      String @id @default(cuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id])

  stripePaymentIntentId String?       @unique // Optionnel pour les paiements manuels
  status                PaymentStatus @default(PENDING)
  amount                Float
  currency              String        @default("eur")

  // Métadonnées Stripe
  stripeMetadata Json?

  // Pour les paiements manuels
  isManual            Boolean              @default(false)
  manualPaymentMethod ManualPaymentMethod?
  manualPaymentNote   String?
  recordedBy          String? // ID de l'admin/moniteur qui a enregistré le paiement
  recordedByUser      User?                @relation(fields: [recordedBy], references: [id])

  // Relation avec les OrderItems (many-to-many via PaymentAllocation)
  allocations PaymentAllocation[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([stripePaymentIntentId])
  @@index([status, createdAt])
  @@index([status, isManual, createdAt])
}

// Table pour éviter le traitement multiple des webhooks Stripe (idempotence)
model ProcessedWebhookEvent {
  id            String   @id @default(cuid())
  stripeEventId String   @unique // ID de l'événement Stripe (evt_xxx)
  eventType     String // Type d'événement (payment_intent.succeeded, etc.)
  processedAt   DateTime @default(now())

  @@index([stripeEventId])
  @@index([eventType])
}
